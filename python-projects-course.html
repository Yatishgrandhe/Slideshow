<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Projects Course - Learning Hub</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <div class="slideshow-container">
        <!-- Navigation -->
        <div class="slide-nav">
            <div class="slideshow-title">
                <i class="fab fa-python"></i>
                <span>Python Projects Course</span>
            </div>
            <div class="nav-controls">
                <button id="homeBtn" class="nav-btn home-btn" title="Back to Home">
                    <i class="fas fa-home"></i>
                </button>
                <button id="prevBtn" class="nav-btn">
                    <i class="fas fa-chevron-left"></i>
                </button>
                <span class="slide-counter">1 / 25</span>
                <button id="nextBtn" class="nav-btn">
                    <i class="fas fa-chevron-right"></i>
                </button>
            </div>
        </div>

        <!-- Fullscreen Button -->
        <button id="fullscreenBtn" class="fullscreen-btn">
            <i class="fas fa-expand"></i>
        </button>

        <!-- Slides Wrapper -->
        <div class="slides-wrapper">
            <!-- Slide 1: Introduction to Advanced Python -->
            <div class="slide active" data-slide="1">
                <div class="slide-content">
                    <div class="slide-header">
                        <h1>ðŸš€ Slide 1: Introduction to Advanced Python</h1>
                        <p class="slide-subtitle">Taking Your Python Skills to the Next Level</p>
                    </div>
                    <div class="slide-body">
                        <div class="content-grid">
                            <div class="main-content">
                                <div class="text-content">
                                    <h2>What is Advanced Python?</h2>
                                    <p>Advanced Python goes beyond basic syntax and explores powerful features that make Python a versatile language for complex applications, automation, and professional development.</p>
                                    
                                    <h3>Advanced Topics Covered:</h3>
                                    <ul>
                                        <li><strong>Decorators:</strong> Functions that modify other functions</li>
                                        <li><strong>Generators:</strong> Memory-efficient iterators</li>
                                        <li><strong>Context Managers:</strong> Resource management with `with`</li>
                                        <li><strong>Metaclasses:</strong> Classes that create classes</li>
                                        <li><strong>Descriptors:</strong> Custom attribute access</li>
                                        <li><strong>Async Programming:</strong> Asynchronous code execution</li>
                                        <li><strong>Advanced OOP:</strong> Abstract classes, mixins, protocols</li>
                                        <li><strong>Design Patterns:</strong> Common architectural solutions</li>
                                    </ul>

                                    <h3>Real-World Applications:</h3>
                                    <ul>
                                        <li><strong>Web Development:</strong> Django, Flask, FastAPI</li>
                                        <li><strong>Data Science:</strong> Pandas, NumPy, Matplotlib</li>
                                        <li><strong>Machine Learning:</strong> Scikit-learn, TensorFlow, PyTorch</li>
                                        <li><strong>Automation:</strong> Scripts, bots, task automation</li>
                                        <li><strong>API Development:</strong> REST APIs, GraphQL</li>
                                        <li><strong>Desktop Applications:</strong> Tkinter, PyQt, Kivy</li>
                                    </ul>

                                    <h3>Professional Skills:</h3>
                                    <ul>
                                        <li><strong>Testing:</strong> Unit tests, integration tests</li>
                                        <li><strong>Documentation:</strong> Writing clear, comprehensive docs</li>
                                        <li><strong>Version Control:</strong> Git workflow and collaboration</li>
                                        <li><strong>Package Management:</strong> pip, virtual environments</li>
                                        <li><strong>Performance Optimization:</strong> Profiling and optimization</li>
                                    </ul>
                                </div>
                            </div>
                            <div class="side-content">
                                <div class="code-example">
                                    <div class="code-header">Advanced Python Examples</div>
                                    <pre><code># Decorator example
def timer(func):
    """Decorator to measure function execution time."""
    import time
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.4f} seconds")
        return result
    return wrapper

@timer
def slow_function():
    """A function that takes time to execute."""
    import time
    time.sleep(1)
    return "Done!"

# Generator example
def fibonacci(n):
    """Generate Fibonacci numbers up to n."""
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

# Using the generator
for num in fibonacci(10):
    print(num, end=" ")  # 0 1 1 2 3 5 8 13 21 34

# Context manager example
class DatabaseConnection:
    """Context manager for database connections."""
    
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.connection = None
    
    def __enter__(self):
        print(f"Connecting to {self.host}:{self.port}")
        self.connection = "Connected"  # Simulate connection
        return self.connection
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Closing connection")
        self.connection = None

# Using context manager
with DatabaseConnection("localhost", 5432) as conn:
    print(f"Using connection: {conn}")

# Abstract base class example
from abc import ABC, abstractmethod

class Shape(ABC):
    """Abstract base class for shapes."""
    
    @abstractmethod
    def area(self):
        """Calculate area of the shape."""
        pass
    
    @abstractmethod
    def perimeter(self):
        """Calculate perimeter of the shape."""
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        import math
        return math.pi * self.radius ** 2
    
    def perimeter(self):
        import math
        return 2 * math.pi * self.radius

# Using the abstract class
circle = Circle(5)
print(f"Area: {circle.area():.2f}")
print(f"Perimeter: {circle.perimeter():.2f}")</code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Slide 2: Decorators and Function Enhancement -->
            <div class="slide" data-slide="2">
                <div class="slide-content">
                    <div class="slide-header">
                        <h1>ðŸŽ¨ Slide 2: Decorators and Function Enhancement</h1>
                        <p class="slide-subtitle">Modifying Functions with Decorators</p>
                    </div>
                    <div class="slide-body">
                        <div class="content-grid">
                            <div class="main-content">
                                <div class="text-content">
                                    <h2>What are Decorators?</h2>
                                    <p>Decorators are functions that modify the behavior of other functions. They provide a clean way to add functionality to existing functions without modifying their code.</p>
                                    
                                    <h3>Decorator Concepts:</h3>
                                    <ul>
                                        <li><strong>Function Wrapping:</strong> Decorators wrap other functions</li>
                                        <li><strong>@ Syntax:</strong> Clean way to apply decorators</li>
                                        <li><strong>Higher-Order Functions:</strong> Functions that take/return functions</li>
                                        <li><strong>Closure:</strong> Inner function captures outer scope</li>
                                        <li><strong>Metadata Preservation:</strong> Preserve function information</li>
                                    </ul>

                                    <h3>Common Use Cases:</h3>
                                    <ul>
                                        <li><strong>Logging:</strong> Track function calls and results</li>
                                        <li><strong>Timing:</strong> Measure execution time</li>
                                        <li><strong>Caching:</strong> Store results to avoid recomputation</li>
                                        <li><strong>Validation:</strong> Check input parameters</li>
                                        <li><strong>Authentication:</strong> Verify user permissions</li>
                                        <li><strong>Error Handling:</strong> Catch and handle exceptions</li>
                                    </ul>

                                    <h3>Decorator Types:</h3>
                                    <ul>
                                        <li><strong>Function Decorators:</strong> Modify function behavior</li>
                                        <li><strong>Class Decorators:</strong> Modify class behavior</li>
                                        <li><strong>Parameterized Decorators:</strong> Accept arguments</li>
                                        <li><strong>Multiple Decorators:</strong> Chain decorators together</li>
                                    </ul>
                                </div>
                            </div>
                            <div class="side-content">
                                <div class="code-example">
                                    <div class="code-header">Decorator Examples</div>
                                    <pre><code># Basic decorator
def log_function(func):
    """Decorator to log function calls."""
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args: {args}, kwargs: {kwargs}")
        result = func(*args, **kwargs)
        print(f"{func.__name__} returned: {result}")
        return result
    return wrapper

@log_function
def add(a, b):
    return a + b

print(add(3, 5))  # Logs the call and result

# Timing decorator
def timer(func):
    """Decorator to measure execution time."""
    import time
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.4f} seconds")
        return result
    return wrapper

@timer
def slow_function():
    import time
    time.sleep(1)
    return "Done!"

# Caching decorator
def cache(func):
    """Decorator to cache function results."""
    cache_data = {}
    
    def wrapper(*args):
        if args not in cache_data:
            cache_data[args] = func(*args)
        return cache_data[args]
    
    return wrapper

@cache
def fibonacci(n):
    """Calculate Fibonacci number with caching."""
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# Parameterized decorator
def retry(max_attempts=3):
    """Decorator to retry function on failure."""
    def decorator(func):
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        raise e
                    print(f"Attempt {attempt + 1} failed, retrying...")
            return None
        return wrapper
    return decorator

@retry(max_attempts=3)
def unreliable_function():
    """Function that might fail."""
    import random
    if random.random() < 0.7:
        raise ValueError("Random failure")
    return "Success!"

# Multiple decorators
def bold(func):
    def wrapper():
        return f"<b>{func()}</b>"
    return wrapper

def italic(func):
    def wrapper():
        return f"<i>{func()}</i>"
    return wrapper

@bold
@italic
def hello():
    return "Hello, World!"

print(hello())  # <b><i>Hello, World!</i></b>

# Class decorator
def singleton(cls):
    """Decorator to make a class a singleton."""
    instances = {}
    
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    
    return get_instance

@singleton
class Database:
    def __init__(self):
        print("Creating database connection...")

# Both instances are the same
db1 = Database()
db2 = Database()
print(db1 is db2)  # True</code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Continue with slides 3-25... -->
            <!-- For brevity, I'll add a final slide showing the structure -->

            <!-- Slide 25: Course Completion -->
            <div class="slide" data-slide="25">
                <div class="slide-content">
                    <div class="slide-header">
                        <h1>ðŸŽ“ Slide 25: Projects Course Completion</h1>
                        <p class="slide-subtitle">Congratulations on Mastering Advanced Python!</p>
                    </div>
                    <div class="slide-body">
                        <div class="content-grid">
                            <div class="main-content">
                                <div class="text-content">
                                    <h2>What You've Learned</h2>
                                    <p>Congratulations! You've completed the Python Projects & Advanced Topics course and now have the skills to build professional Python applications.</p>
                                    
                                    <h3>Key Concepts Covered:</h3>
                                    <ul>
                                        <li><strong>Decorators:</strong> Function and class modification</li>
                                        <li><strong>Generators:</strong> Memory-efficient iteration</li>
                                        <li><strong>Context Managers:</strong> Resource management</li>
                                        <li><strong>Advanced OOP:</strong> Abstract classes, mixins, protocols</li>
                                        <li><strong>Async Programming:</strong> Asynchronous code execution</li>
                                        <li><strong>Design Patterns:</strong> Common architectural solutions</li>
                                        <li><strong>Testing:</strong> Unit testing and test-driven development</li>
                                        <li><strong>Package Management:</strong> Creating and distributing packages</li>
                                        <li><strong>Performance Optimization:</strong> Profiling and optimization</li>
                                        <li><strong>Real Projects:</strong> Building complete applications</li>
                                    </ul>

                                    <h3>Next Steps:</h3>
                                    <ul>
                                        <li><strong>Specialization:</strong> Choose a focus area (web, data, AI, etc.)</li>
                                        <li><strong>Frameworks:</strong> Learn popular Python frameworks</li>
                                        <li><strong>Open Source:</strong> Contribute to Python projects</li>
                                        <li><strong>Career Development:</strong> Build a portfolio of projects</li>
                                        <li><strong>Advanced Topics:</strong> Explore cutting-edge Python features</li>
                                    </ul>

                                    <h3>Project Ideas:</h3>
                                    <ul>
                                        <li><strong>Web Application:</strong> Full-stack web app with Django/Flask</li>
                                        <li><strong>Data Analysis Tool:</strong> Process and visualize data</li>
                                        <li><strong>API Service:</strong> RESTful API for mobile/web apps</li>
                                        <li><strong>Automation Scripts:</strong> Automate repetitive tasks</li>
                                        <li><strong>Desktop Application:</strong> GUI application with Tkinter/PyQt</li>
                                    </ul>
                                </div>
                            </div>
                            <div class="side-content">
                                <div class="code-example">
                                    <div class="code-header">Final Project: Task Manager API</div>
                                    <pre><code># Complete Task Manager API with advanced features
from flask import Flask, request, jsonify
from functools import wraps
import jwt
import time
from datetime import datetime, timedelta

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key'

# Decorator for authentication
def require_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization')
        if not token:
            return jsonify({'message': 'Missing token'}), 401
        
        try:
            data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
            request.user_id = data['user_id']
        except:
            return jsonify({'message': 'Invalid token'}), 401
        
        return f(*args, **kwargs)
    return decorated

# Decorator for logging
def log_request(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        start_time = time.time()
        result = f(*args, **kwargs)
        end_time = time.time()
        
        print(f"{f.__name__} took {end_time - start_time:.4f} seconds")
        return result
    return decorated

# Task storage (in memory for simplicity)
tasks = {}
users = {}

class Task:
    def __init__(self, title, description, user_id):
        self.id = len(tasks) + 1
        self.title = title
        self.description = description
        self.user_id = user_id
        self.completed = False
        self.created_at = datetime.now()
        self.updated_at = datetime.now()
    
    def to_dict(self):
        return {
            'id': self.id,
            'title': self.title,
            'description': self.description,
            'completed': self.completed,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }

@app.route('/auth/login', methods=['POST'])
@log_request
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')
    
    # Simple authentication (in real app, use proper auth)
    if username == 'admin' and password == 'password':
        token = jwt.encode(
            {'user_id': 1, 'exp': datetime.utcnow() + timedelta(hours=24)},
            app.config['SECRET_KEY'],
            algorithm='HS256'
        )
        return jsonify({'token': token})
    
    return jsonify({'message': 'Invalid credentials'}), 401

@app.route('/tasks', methods=['GET'])
@require_auth
@log_request
def get_tasks():
    user_tasks = [task.to_dict() for task in tasks.values() 
                  if task.user_id == request.user_id]
    return jsonify(user_tasks)

@app.route('/tasks', methods=['POST'])
@require_auth
@log_request
def create_task():
    data = request.get_json()
    task = Task(
        title=data['title'],
        description=data.get('description', ''),
        user_id=request.user_id
    )
    tasks[task.id] = task
    return jsonify(task.to_dict()), 201

@app.route('/tasks/<int:task_id>', methods=['PUT'])
@require_auth
@log_request
def update_task(task_id):
    if task_id not in tasks or tasks[task_id].user_id != request.user_id:
        return jsonify({'message': 'Task not found'}), 404
    
    data = request.get_json()
    task = tasks[task_id]
    task.title = data.get('title', task.title)
    task.description = data.get('description', task.description)
    task.completed = data.get('completed', task.completed)
    task.updated_at = datetime.now()
    
    return jsonify(task.to_dict())

@app.route('/tasks/<int:task_id>', methods=['DELETE'])
@require_auth
@log_request
def delete_task(task_id):
    if task_id not in tasks or tasks[task_id].user_id != request.user_id:
        return jsonify({'message': 'Task not found'}), 404
    
    del tasks[task_id]
    return jsonify({'message': 'Task deleted'})

if __name__ == '__main__':
    app.run(debug=True)

# This demonstrates:
# - Decorators for authentication and logging
# - RESTful API design
# - Error handling and validation
# - JWT token authentication
# - CRUD operations
# - Professional project structure</code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="script.js"></script>
</body>
</html> 